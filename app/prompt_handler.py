import numpy as np
import pandas as pd
import os
import faiss
from openai import Client, OpenAI


OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

def prompt_handler(prompt: str):
    final_response = generate_response(prompt)
    return final_response


def generate_response(user_prompt: str) -> str:
    """
    Generates a response by embedding the user prompt, finding the nearest neighbors in a preloaded 
    embeddings dataset, and creating a final response based on selected professionals' profiles.

    Args:
        user_prompt (str): The input prompt from the user to generate a response for.

    Returns:
        str: The final response generated by the GPT model based on system prompt and professional profiles.
    """
    
    client = OpenAI(
        api_key=OPENAI_API_KEY,
    )

    # Generate embeddings for the user prompt using the specified model
    embedding_user = client.embeddings.create(
        input=user_prompt,
        model="text-embedding-ada-002"  # Recommended model for embeddings
    )

    # Extract the embeddings into a NumPy array
    embedding_user_array = np.array(embedding_user.data[0].embedding)
    
    # Load pre-computed normalized embeddings
    normalized_embeddings = np.load("normalized_embeddings.npy")
    
    # Find the nearest neighbors using FAISS (with k=4)
    indices, distances = find_nearest_neighbors_faiss(normalized_embeddings, embedding_user_array, k=4)
    
    # Load professional profiles from a CSV
    profile_df = pd.read_csv("experts_profile.csv")
    selected_professionals = []
    
    # Append the profiles of the most similar professionals
    for n in indices[0]:
        selected_professionals.append(create_profile_prompt(profile_df.iloc[n]))

    # Convert the list into a single string, separated by new lines
    selected_professionals_string = "\n".join(selected_professionals)
    
    # Build the system prompt combining the user prompt and selected professional profiles
    system_prompt = build_system_prompt(user_prompt, selected_professionals_string)
    
    # Generate a response using the GPT-4 model
    cv_helper_chat = client.chat.completions.create(
        messages=[
            {
                "role": "user",
                "content": system_prompt,
            }
        ],
        model="gpt-4o",
    )

    # Extract the content of the response message
    final_response = cv_helper_chat.choices[0].message.content
    
    return final_response


def find_nearest_neighbors_faiss(normalized_embeddings: np.ndarray, unit_vector: np.ndarray, k: int = 4) -> tuple:
    """
    Creates a FAISS index using L2 distance (which acts like cosine similarity for normalized vectors), 
    adds normalized embeddings to the index, and finds the k nearest neighbors to a query vector.

    Parameters:
    normalized_embeddings (np.ndarray): A 2D array of normalized embeddings to be added to the FAISS index.
    unit_vector (np.ndarray): The query vector, which should also be normalized and reshaped to (1, dimension).
    k (int): The number of nearest neighbors to find. Default is 4.

    Returns:
    tuple: A tuple containing two elements:
        - indices (np.ndarray): The indices of the k nearest neighbors in the embedding space.
        - distances (np.ndarray): The corresponding distances to the nearest neighbors.
    """
    
    # Step 1: Get the dimensionality of the embeddings
    dimension = normalized_embeddings.shape[1]
    
    # Step 2: Create a FAISS index based on L2 distance
    index = faiss.IndexFlatL2(dimension)
    
    # Step 3: Add normalized embeddings to the FAISS index
    index.add(normalized_embeddings)
    
    # Step 4: Ensure the query vector is reshaped to (1, dimension)
    query_vector = unit_vector.reshape(1, -1)
    
    # Step 5: Perform the search for the k nearest neighbors
    distances, indices = index.search(query_vector, k)
    
    # Return the indices of the nearest neighbors and their corresponding distances
    return indices, distances


def build_system_prompt(user_prompt: str, selected_professionals_string: str):
    system_prompt = f""" You are a chatbot for a staff enhancement company. 
        Your goal is to assist employees in finding professionals inside the company who can help them if they have questions.
        
        The user query in this case is: {user_prompt}
        
        And you have the next list of experts who can help him:
        {selected_professionals_string}.

        Answer cordially with the name of the experts and a brief description of the their expertise and technology knowledge. 
        In the end, make a subjective evaluation of the expert, and say how much do you think he/she can help
    """
    return system_prompt



def create_profile_prompt(input_dataframe: pd.DataFrame) -> str:
    """
    Generates a profile prompt string using specific information from the input DataFrame.
    
    Args:
        input_dataframe (pd.DataFrame): A DataFrame containing columns such as 'Name', 
                                        'Partner', 'Industry', 'Technologies', and 'Processed_CV'.
                                        
    Returns:
        str: A formatted string that describes the person's profile based on the DataFrame content.
    """
    profile_prompt_string = f""" {input_dataframe["Name"]} works in 
    {input_dataframe["Partner"]}, a company of {input_dataframe["Industry"]}
    which works with these technologies {input_dataframe["Technologies"]}.
    He has expertise in {input_dataframe["Processed_CV"]}
    """
    
    return profile_prompt_string
